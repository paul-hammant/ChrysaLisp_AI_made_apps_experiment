(include "lib/asm/func.inc")
(include "./class.inc")
(include "class/list/class.inc")
(include "sys/math/class.inc")

(def-method 'path :stroke_polyline)
	;inputs
	;:r0 = path object (ptr)
	;:r1 = stack array object (ptr)
	;:r2 = radius (fixed)
	;:r3 = tolerance (fixed)
	;:r4 = join style (byte)
	;:r5 = cap style1 (byte)
	;:r6 = cap style2 (byte)
	;outputs
	;:r0 = path object (ptr)
	;:r1 = output path object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(union
			(ulong p1 p2 p3 p4 l2_v l2_pv l2_npv l2_rv l1_v l1_npv l1_rv)
			(int p1x p1y p2x p2y p3x p3y p4x p4y
				l2_vx l2_vy l2_pvx l2_pvy l2_npvx l2_npvy l2_rvx l2_rvy
				l1_vx l1_vy l1_npvx l1_npvy l1_rvx l1_rvy))
		(plong iter iter_begin iter_end)
		(ptr this stack path1)
		(int radius eps step c c1)
		(byte join_style cap1_style cap2_style))

	(push-scope)
	(scope-used l2_pv p3 p4)
	(entry 'path :stroke_polyline {this, stack, radius, eps, join_style, cap1_style, cap2_style})

	(vec-set 0)
	(call 'path :filter_polyline {this, this, 0.5})
	(call 'path :create :nil {path1})
	(call 'path :get_both {this} {_, iter, iter_end})
	(vpif {iter_end - iter >= 4 * +ptr_size})
		(assign {iter - (2 * +long_size), (2 * +long_size)} {iter_begin, step})
		(loop-start)
			(assign {iter[0]} {p1x})
			(assign {iter[+long_size]} {p1y})
			(assign {iter + step} {iter})
			(assign {iter[0]} {p2x})
			(assign {iter[+long_size]} {p2y})
			(assign {iter + step} {iter})
			(vec-load 2 {p2x, p2y} {p1x, p1y})
			(vec-sub 2)
			(vec-tee 2 {l2_vx, l2_vy})
			(vec-perp)
			(vec-tee 2 {l2_pvx, l2_pvy})
			(vec-fnorm 2)
			(vec-tee 2 {l2_npvx, l2_npvy})
			(vec-load 1 {radius})
			(vec-fscale 2)
			(vec-store 2 {l2_rvx, l2_rvy})

			(vpif {step > 0})
				(assign {cap1_style} {c})
			(else)
				(assign {cap2_style} {c})
			(endif)
			(switch)
			(vpcase {c = cap_butt})
				;butt cap
				(vec-load 2 {p1x, p1y})
				(vec-goto 'out_cap)
			(vpcase {c = cap_square})
				;square cap
				(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
				(vec-perp)
				(vec-add 2)
			(vp-label 'out_cap)
				(vec-load 2 {l2_rvx, l2_rvy})
				(vec-dup 4)
				(vec-sub 2)
				(vec-goto 'store_p3p4)
			(vpcase {c = cap_tri})
				;triangle cap
				(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
				(vec-dup 4)
				(vec-dup 4)
				(vec-sub 2)
				(vec-store 2 {p1x, p1y})
				(vec-perp)
				(vec-add 2)
				(vec-store 2 {p3x, p3y})
				(vec-add 2)
				(vec-store 2 {p4x, p4y})
				(call 'path :push_back2 {path1, p1x, p1y})
				(goto 'out_p3p4)
			(vpcase {c = cap_arrow})
				;arrow cap
				(vec-load 2 {l2_rvx, l2_rvy})
				(vec-shl 2 1)
				(vec-store 2 {p3x, p3y})
				(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
				(vec-sub 2)
				(vec-store 2 {p4x, p4y})
				(call 'path :push_back2 {path1, p4x, p4y})
				(vec-load 2 {p1x, p1y} {p3x, p3y})
				(vec-sub 2)
				(vec-store 2 {p4x, p4y})
				(call 'path :push_back2 {path1, p4x, p4y})
				(vec-load 2 {p1x, p1y} {p3x, p3y})
				(vec-perp)
				(vec-add 2)
				(vec-store 2 {p4x, p4y})
				(call 'path :push_back2 {path1, p4x, p4y})
				(vec-load 2 {l2_rvx, l2_rvy} {p1x, p1y})
				(vec-dup 2)
				(vec-load 2 {p3x, p3y})
				(vec-add 2)
			(vp-label 'store_p3p4)
				(vec-store 2 {p3x, p3y})
				(vec-add 2)
				(vec-store 2 {p4x, p4y})
			(vp-label 'out_p3p4)
				(call 'path :push_back2 {path1, p3x, p3y})
				(call 'path :push_back2 {path1, p4x, p4y})
			(else)
				;round cap
				(vec-load 2 {l2_rvx, l2_rvy})
				(vec-dup 2)
				(vec-perp)
				(vec-store 2 {p3x, p3y})
				(vec-load 1 {-1})
				(vec-scale 2)
				(vec-store 2 {p4x, p4y})
				(call 'path :gen_clerp {path1, stack, p1x, p1y, p4x, p4y, p3x, p3y, radius})
				(call 'path :gen_clerp {path1, stack, p1x, p1y, p3x, p3y, l2_rvx, l2_rvy, radius})
			(endswitch)
			(loop-while {iter /= iter_begin && iter /= iter_end})
				(vec-load 4 {p2, l2_v, l2_npv, l2_rv})
				(vec-store 4 {p1, l1_v, l1_npv, l1_rv})
				(assign {iter[0]} {p2x})
				(assign {iter[+long_size]} {p2y})
				(assign {iter + step} {iter})
				(vec-load 2 {p2x, p2y} {p1x, p1y})
				(vec-sub 2)
				(vec-tee 2 {l2_vx, l2_vy})
				(vec-perp)
				(vec-tee 2 {l2_pvx, l2_pvy})
				(vec-fnorm 2)
				(vec-tee 2 {l2_npvx, l2_npvy})
				(vec-load 1 {radius})
				(vec-fscale 2)
				(vec-store 2 {l2_rvx, l2_rvy})

				;what kind of join
				(vec-load 2 {l1_npvx, l1_npvy} {l2_npvx, l2_npvy})
				(vec-dup 4)
				(vec-perp)
				(vec-fdot 2)
				(vec-store 1 {c})
				(vec-fdot 2)
				(vec-store 1 {c1})

				(switch)
				(vpcase {(c < 0.01) && (c > -0.01) || (c1 < -0.9)})
					;acuracy limit
					(goto 'do_bevel)
				(vpcase {c <= 0 || join_style = join_miter})
					;mitre join
					(vec-load 2 {p1x, p1y})
					(vec-dup 2)
					(vec-load 4 {l1_rvx, l1_rvy, l2_rvx, l2_rvy})
					(vec-add 4)
					(vec-store 4 {p3x, p3y, p1x, p1y})
					(call 'sys_math :f_intersect {p3x, p3y, p1x, p1y, l1_vx, l1_vy, l2_vx, l2_vy} {p1x, p1y})
					(goto 'out_p1)
				(vpcase {join_style = join_bevel})
				(vp-label 'do_bevel)
					;bevel join
					(vec-load 2 {p1x, p1y})
					(vec-dup 2)
					(vec-load 4 {l1_rvx, l1_rvy, l2_rvx, l2_rvy})
					(vec-add 4)
					(vec-store 4 {p3x, p3y, p1x, p1y})
					(call 'path :push_back2 {path1, p3x, p3y})
				(vp-label 'out_p1)
					(call 'path :push_back2 {path1, p1x, p1y})
				(else)
					;rounded join
					(call 'path :gen_clerp {path1, stack, p1x, p1y, l1_rvx, l1_rvy, l2_rvx, l2_rvy, radius})
				(endswitch)
			(loop-end)
			(breakif {step < 0})
			(assign {-step} {step})
			(assign {iter + step} {iter})
		(loop-end)
	(endif)

	(exit 'path :stroke_polyline {this, path1})
	(pop-scope)
	(return)

(def-func-end)
