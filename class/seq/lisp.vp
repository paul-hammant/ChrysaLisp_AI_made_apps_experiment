(include "lib/asm/func.inc")
(include "./class.inc")
(include "././num/class.inc")
(include "././hmap/class.inc")
(include "././str/class.inc")
(include "gui/path/class.inc")
(include "././lisp/class.inc")

(def-method 'seq :lisp_length)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry 'seq :lisp_length '(:r0 :r1))

	(errorif-lisp-args-sig :r1 1 'error1)

	(vp-cpy-rr :r0 :r13)
	(defq in (method-input 'seq :get_length))
	(list-bind-args :r1 in '(:seq))
	(call 'seq :get_length in '(_ len))
	(call 'num :create `(,len) '(:r1))

	(exit 'seq :lisp_length '(:r13 :r1))
	(vp-ret)

(errorcase
(vp-label 'error1)
	(jump 'lisp :repl_error '(:r0 "(length seq)" +error_msg_wrong_types :r1))
	(signature '(seq)))

(def-func-end)

(def-method 'seq :lisp_elem)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry 'seq :lisp_elem '(:r0 :r1))

	(errorif-lisp-args-sig :r1 2 'error1)
(errorcase
	(assign '(:r1) '(:r13)))

	(assign '(:r0) '(:r12))
	(list-bind-args :r1 '(:r11 :r0) '(:num :seq))
	(call 'seq :get_length '(:r0) '(:r0 :r1))
	(lisp-elem-index :r11 :r1)
(errorcase
	(gotoif '(:r11 < 0) 'error2)
	(gotoif '(:r11 >= :r1) 'error2))
	(call 'seq :ref_element '(:r0 :r11) '(_ :r1))

	(exit 'seq :lisp_elem '(:r12 :r1))
	(vp-ret)

(errorcase
(vp-label 'error1)
	(jump 'lisp :repl_error '(:r0 "(elem-get index seq)" +error_msg_wrong_types :r1))
(vp-label 'error2)
	(jump 'lisp :repl_error '(:r12 "(elem-get index seq)" +error_msg_not_valid_index :r13))
	(signature '(num seq)))

(def-func-end)

(def-method 'seq :lisp_slice)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry 'seq :lisp_slice '(:r0 :r1))

	(errorif-lisp-args-sig :r1 3 'error1)
(errorcase
	(assign '(:r1) '(:r13)))

	(assign '(:r0) '(:r12))
	(list-bind-args :r1 '(:r10 :r11 :r0) '(:num :num :seq))
	(call 'seq :get_length '(:r0) '(:r0 :r1))
	(lisp-elem-index :r10 :r1)
	(lisp-elem-index :r11 :r1)
(errorcase
	(gotoif '(:r10 < 0) 'error2)
	(gotoif '(:r10 > :r11) 'error2)
	(gotoif '(:r11 > :r1) 'error2))
	(call 'seq :slice '(:r0 :r10 :r11) '(_ :r1))

	(exit 'seq :lisp_slice '(:r12 :r1))
	(vp-ret)

(errorcase
(vp-label 'error1)
	(jump 'lisp :repl_error '(:r0 "(slice start end seq)" +error_msg_wrong_types :r1))
(vp-label 'error2)
	(jump 'lisp :repl_error '(:r12 "(slice start end seq)" +error_msg_not_valid_index :r13))
	(signature '(num num seq)))

(def-func-end)

(def-method 'seq :lisp_cat)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry 'seq :lisp_cat '(:r0 :r1))

(errorcase
	(call 'lisp :env_args_type `(:r1 (@ ,(f-path 'str :vtable)) 1) '(tmp))
	(vpif `(,tmp = 0))
		(call 'lisp :env_args_match `(:r1 (@ ,(f-path 'seq :vtable)) 1) '(tmp))
		(gotoif `(,tmp = 0) 'error)
	(endif))

	(assign '(:r0) '(:r13))
	(array-bind-args :r1 '(:r0))
	(call 'seq :cat '(:r0 :r1) '(:r0))

	(exit 'seq :lisp_cat '(:r13 :r0))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(cat seq ...)" +error_msg_wrong_types :r1)))

(def-func-end)

(def-method 'seq :lisp_find)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(vp-def (element sequence idx vtable ovtable args)
		'(:r8 :r9 :r10 :r11 :r12 :r13))

	(entry 'seq :lisp_find '(:r0 :r1))

	(errorif-lisp-args-sig-range :r1 2 3 'error)

	(assign '((:r1 array_length)) '(:r2))
	(vp-cpy-rr :r1 args)
	(vp-push :r0)
	(vpif '(:r2 = 3))
		(list-bind-args :r1 `(,element ,sequence ,idx) '(:obj :seq :num))
	(else)
		(list-bind-args :r1 `(,element ,sequence) '(:obj :seq))
		(vp-cpy-cr 0 idx)
	(endif)
	(assign `((,sequence obj_vtable)) `(,ovtable))
	(switch)
	(f-bind 'str :vtable vtable)
	(vpcase (list ovtable '= vtable))
	(errorcase
		(assign `((,element obj_vtable)) `(,ovtable))
		(gotoif (list ovtable '/= vtable) 'error1))
		(list-cast-args `(,element) '(:char))
		(goto 'dofind)
	(default)
		(f-bind 'list :vtable vtable)
		(gotoif (list ovtable '= vtable) 'dofind)
	(errorcase
		(call 'obj :inst_of `(,element (@ ,(f-path 'num :vtable))) '(_ tmp))
		(gotoif `(,tmp = 0) 'error1))
		(list-cast-args `(,element) '(:num))
	(vp-label 'dofind)
		(call 'seq :get_length `(,sequence) '(:r0 :r1))
		(gotoif '(:r1 = 0) 'empty)
		(lisp-elem-index idx :r1)
	(errorcase
		(gotoif `(,idx < 0) 'error2)
		(gotoif `(,idx > :r1) 'error2))
		(call 'seq :find `(:r0 ,element ,idx) '(_ _ idx))
		(vpif `(,idx = -1))
		(vp-label 'empty)
			(assign '((:rsp 0)) '(:r0))
			(call 'obj :ref '((:r0 lisp_sym_nil)) '(:r0))
		(else)
			(call 'num :create `(,idx) '(:r0))
		(endif)
	(endswitch)
	(vp-cpy-rr :r0 :r1)
	(vp-pop :r0)

	(exit 'seq :lisp_find '(:r0 :r1))
	(vp-ret)

(errorcase
(vp-label 'error2)
	(vp-pop :r0)
	(jump 'lisp :repl_error `(:r0 "(find elem seq [idx])" +error_msg_not_valid_index ,args))
(vp-label 'error1)
	(vp-pop :r0)
	(vp-cpy-rr args :r1)
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(find elem seq [idx])" +error_msg_wrong_types :r1))
	(signature '(obj seq num)))

(def-func-end)

(def-method 'seq :lisp_rfind)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(vp-def (element sequence idx vtable ovtable args)
		'(:r8 :r9 :r10 :r11 :r12 :r13))

	(entry 'seq :lisp_rfind '(:r0 :r1))

	(errorif-lisp-args-sig-range :r1 2 3 'error)

	(assign '((:r1 array_length)) '(:r2))
	(vp-cpy-rr :r1 args)
	(vp-push :r0)
	(vpif '(:r2 = 3))
		(list-bind-args :r1 `(,element ,sequence ,idx) '(:obj :seq :num))
	(else)
		(list-bind-args :r1 `(,element ,sequence) '(:obj :seq))
		(vp-cpy-cr -1 idx)
	(endif)
	(assign `((,sequence obj_vtable)) `(,ovtable))
	(switch)
	(f-bind 'str :vtable vtable)
	(vpcase (list ovtable '= vtable))
	(errorcase
		(assign `((,element obj_vtable)) `(,ovtable))
		(gotoif (list ovtable '/= vtable) 'error1))
		(list-cast-args `(,element) '(:char))
		(goto 'dofind)
	(default)
		(f-bind 'list :vtable vtable)
		(gotoif (list ovtable '= vtable) 'dofind)
	(errorcase
		(call 'obj :inst_of `(,element (@ ,(f-path 'num :vtable))) '(_ tmp))
		(gotoif `(,tmp = 0) 'error1))
		(list-cast-args `(,element) '(:num))
	(vp-label 'dofind)
		(call 'seq :get_length `(,sequence) '(:r0 :r1))
		(gotoif '(:r1 = 0) 'empty)
		(lisp-elem-index idx :r1)
	(errorcase
		(gotoif `(,idx < 0) 'error2)
		(gotoif `(,idx > :r1) 'error2))
		(call 'seq :rfind `(:r0 ,element ,idx) '(_ _ idx))
		(vpif `(,idx = -1))
		(vp-label 'empty)
			(assign '((:rsp 0)) '(:r0))
			(call 'obj :ref '((:r0 lisp_sym_nil)) '(:r0))
		(else)
			(call 'num :create `(,idx) '(:r0))
		(endif)
	(endswitch)
	(vp-cpy-rr :r0 :r1)
	(vp-pop :r0)

	(exit 'seq :lisp_rfind '(:r0 :r1))
	(vp-ret)

(errorcase
(vp-label 'error2)
	(vp-pop :r0)
	(jump 'lisp :repl_error `(:r0 "(find-rev elem seq [idx])" +error_msg_not_valid_index ,args))
(vp-label 'error1)
	(vp-pop :r0)
	(vp-cpy-rr args :r1)
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(find-rev elem seq [idx])" +error_msg_wrong_types :r1))
	(signature '(obj seq num)))

(def-func-end)

(def-method 'seq :lisp_first)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry 'seq :lisp_first '(:r0 :r1))

	(errorif-lisp-args-sig :r1 1 'error)

	(assign '(:r0) '(:r13))
	(list-bind-args :r1 '(:r0) '(:seq))
	(call 'seq :get_length '(:r0) '(:r0 :r1))
	(vpif '(:r1 > 0))
		(call 'seq :ref_element '(:r0 0) '(_ :r1))
	(else)
		(assign '((:r13 lisp_sym_nil)) '(:r1))
		(class/obj/ref :r1 :r2)
	(endif)

	(exit 'seq :lisp_first '(:r13 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(first seq)" +error_msg_not_a_sequence :r1))
	(signature '(seq)))

(def-func-end)

(def-method 'seq :lisp_second)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry 'seq :lisp_second '(:r0 :r1))

	(errorif-lisp-args-sig :r1 1 'error)

	(assign '(:r0) '(:r13))
	(list-bind-args :r1 '(:r0) '(:seq))
	(call 'seq :get_length '(:r0) '(:r0 :r1))
	(vpif '(:r1 > 1))
		(call 'seq :ref_element '(:r0 1) '(_ :r1))
	(else)
		(assign '((:r13 lisp_sym_nil)) '(:r1))
		(class/obj/ref :r1 :r2)
	(endif)

	(exit 'seq :lisp_second '(:r13 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(second seq)" +error_msg_not_a_sequence :r1))
	(signature '(seq)))

(def-func-end)

(def-method 'seq :lisp_third)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry 'seq :lisp_third '(:r0 :r1))

	(errorif-lisp-args-sig :r1 1 'error)

	(assign '(:r0) '(:r13))
	(list-bind-args :r1 '(:r0) '(:seq))
	(call 'seq :get_length '(:r0) '(:r0 :r1))
	(vpif '(:r1 > 2))
		(call 'seq :ref_element '(:r0 2) '(_ :r1))
	(else)
		(assign '((:r13 lisp_sym_nil)) '(:r1))
		(class/obj/ref :r1 :r2)
	(endif)

	(exit 'seq :lisp_third '(:r13 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(first seq)" +error_msg_not_a_sequence :r1))
	(signature '(seq)))

(def-func-end)

(def-method 'seq :lisp_last)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry 'seq :lisp_last '(:r0 :r1))

	(errorif-lisp-args-sig :r1 1 'error)

	(assign '(:r0) '(:r13))
	(list-bind-args :r1 '(:r0) '(:seq))
	(call 'seq :get_length '(:r0) '(:r0 :r1))
	(vpif '(:r1 > 0))
		(call 'seq :ref_element '(:r0 (& :r1 -1)) '(_ :r1))
	(else)
		(assign '((:r13 lisp_sym_nil)) '(:r1))
		(class/obj/ref :r1 :r2)
	(endif)

	(exit 'seq :lisp_last '(:r13 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(last seq)" +error_msg_not_a_sequence :r1))
	(signature '(seq)))

(def-func-end)

(def-method 'seq :lisp_rest)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry 'seq :lisp_rest '(:r0 :r1))

	(errorif-lisp-args-sig :r1 1 'error)

	(assign '(:r0) '(:r13))
	(list-bind-args :r1 '(:r0) '(:seq))
	(call 'seq :get_length '(:r0) '(:r0 :r2))
	(vp-cpy-cr 1 :r1)
	(vpif '(:r2 = 0))
		(vp-cpy-rr :r2 :r1)
	(endif)
	(call 'seq :slice '(:r0 :r1 :r2) '(_ :r1))

	(exit 'seq :lisp_rest '(:r13 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(rest seq)" +error_msg_not_a_sequence :r1))
	(signature '(seq)))

(def-func-end)

(def-method 'seq :lisp_most)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry 'seq :lisp_most '(:r0 :r1))

	(errorif-lisp-args-sig :r1 1 'error)

	(assign '(:r0) '(:r13))
	(list-bind-args :r1 '(:r0) '(:seq))
	(call 'seq :get_length '(:r0) '(:r0 :r2))
	(vp-sub-cr 1 :r2)
	(vp-xor-rr :r1 :r1)
	(vpif '(:r2 < 0))
		(vp-cpy-rr :r1 :r2)
	(endif)
	(call 'seq :slice '(:r0 :r1 :r2) '(_ :r1))

	(exit 'seq :lisp_most '(:r13 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(most seq)" +error_msg_not_a_sequence :r1))
	(signature '(seq)))

(def-func-end)

(def-method 'seq :lisp_partition)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(vp-def (seq cnt idx len lst this args idx1)
		'(:r13 :r12 :r11 :r10 :r9 :r0 :r1 :r2))

	(entry 'seq :lisp_partition `(,this ,args))

	(errorif-lisp-args-sig-range :r1 1 2 'error)

	(assign `((,args array_length)) `(,len))
	(vpif `(,len = 1))
		(list-bind-args args `(,seq) '(:seq))
		(vp-cpy-cr 1 cnt)
	(else)
		(list-bind-args args `(,seq ,cnt) '(:seq :num))
		(errorif `(,cnt <= 0) 'error)
	(endif)

	(vp-push this)
	(call 'list :create :nil `(,lst))
	(call 'seq :get_length `(,seq) `(_ ,len))

	(vp-lea-d cnt len :r0)
	(vp-sub-cr 1 :r0)
	(vp-ext-rr :r0 :r2)
	(vp-div-rrr-u cnt :r2 :r0)
	(call 'list :set_capacity `(,lst :r0))

	(vp-cpy-cr 0 idx)
	(loop-while `(,idx < ,len))
		(vp-lea-d idx cnt idx1)
		(vp-min-rr len idx1)
		(call 'seq :slice `(,seq ,idx ,idx1) '(_ slc))
		(call 'list :push_back `(,lst ,slc))
		(vp-add-rr cnt idx)
	(loop-end)
	(vp-pop this)

	(exit 'seq :lisp_partition `(,this ,lst))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error `(,this "(partition seq [cnt])" +error_msg_wrong_types ,args))
	(signature '(seq num)))

(def-func-end)

(def-method 'seq :lisp_each)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this args value func params)
		(int dir start end))

	(push-scope)
	(entry 'seq :lisp_each '(:r0 :r1))

	(errorif-lisp-args-sig :r1 4 'error1)

	(assign '(:r0 :r1) {this, args})
	(call 'lisp :env_push '(:r0))

	(assign {args} '(:r0))
	(list-bind-args :r0 '(:r9 :r10 :r11 :r12) '(:num :num :obj :list))
	(vp-cpy-cr +max_int :r8)
	(class/array/get_both :r12 :r6 :r7)
	(loop-while '(:r6 /= :r7))
		(vp-cpy-ir :r6 0 :r0)
	(errorcase
		(call 'obj :inst_of `(:r0 (@ ,(f-path 'seq :vtable))) '(:r0 :r1))
		(gotoif '(:r1 = 0) 'error3))
		(call 'seq :get_length '(:r0) '(_ :r1))
		(vpif '(:r1 < :r8))
			(vp-cpy-rr :r1 :r8)
		(endif)
		(vp-add-cr +ptr_size :r6)
	(loop-end)

	(call 'obj :ref {this->lisp_sym_nil} {value})

	(vpif '(:r8 /= +max_int))
		(lisp-elem-index :r9 :r8)
		(lisp-elem-index :r10 :r8)

	(errorcase
		(gotoif '(:r9 < 0) 'error4)
		(gotoif '(:r10 < 0) 'error4)
		(gotoif '(:r9 > :r8) 'error4)
		(gotoif '(:r10 > :r8) 'error4))

		(vp-cpy-cr 1 :r8)
		(vpif '(:r9 > :r10))
			(vp-cpy-cr -1 :r8)
			(vp-sub-cr 1 :r9)
			(vp-sub-cr 1 :r10)
		(endif)
		(assign '(:r8 :r9 :r10 :r11 :r12) {dir, start, end, func, args})

		(loop-while '(:r9 /= :r10) 'done)
			(call 'obj :deref {value})

			(call 'list :create :nil {params})
			(assign {args, start} '(:r0 :r9))
			(class/array/get_both :r0 :r10 :r11)
			(loop-start)
				(call 'seq :ref_element '((:r10 0) :r9) '(_ :r1))
				(assign {params} '(:r0))
				(call 'list :push_back '(:r0 :r1))
				(vp-add-cr +ptr_size :r10)
			(loop-until '(:r10 = :r11))

			(call 'num :create '(:r9) '(:r2))
			(assign {this} '(:r1))
			(assign '(:r2) {value})
			(call 'hmap :insert '((:r1 lisp_environment) (:r1 lisp_sym_underscore) :r2))
			(call 'obj :deref {value})

			(call 'lisp :repl_apply {this, params, func} {_, value})
			(call 'list :deref {params})

		(errorcase
			(assign {value} '(:r1))
			(f-bind 'error :vtable :r4)
			(assign '((:r1 obj_vtable)) '(:r3))
			(breakif '(:r3 = :r4) 'done))

			(assign {dir, start, end} '(:r8 :r9 :r10))
			(vp-add-rr :r8 :r9)
			(assign '(:r9) {start})
		(loop-end)
	(endif)

(vp-label 'funcexit)
	(call 'lisp :env_pop {this} '(:r0 _))
	(assign {value} '(:r1))
	(exit 'seq :lisp_each '(:r0 :r1))
	(return)

(errorcase
(vp-label 'error1)
	(jump 'lisp :repl_error '(:r0 "(each! start end lambda seqs)" +error_msg_wrong_num_of_args :r1))
(vp-label 'error3)
	(call 'lisp :repl_error {this, "(each! start end lambda seqs)", +error_msg_not_a_sequence, args} {_, value})
	(goto 'funcexit)
(vp-label 'error4)
	(call 'lisp :repl_error {this, "(each! start end lambda seqs)", +error_msg_not_valid_index, args} {_, value})
	(goto 'funcexit)
	(signature '(num num obj list)))

	(pop-scope-syms)

(def-func-end)

(def-method 'seq :lisp_some)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this args value mode func params)
		(int dir start end))

	(push-scope)
	(entry 'seq :lisp_some '(:r0 :r1))

	(errorif-lisp-args-sig :r1 5 'error1)

	(assign '(:r0 :r1) {this, args})
	(call 'lisp :env_push '(:r0))

	(assign {args} '(:r0))
	(list-bind-args :r0 '(:r9 :r10 :r11 :r12 :r13) '(:num :num :obj :obj :list))
	(vp-cpy-cr +max_int :r8)
	(class/array/get_both :r13 :r6 :r7)
	(loop-while '(:r6 /= :r7))
		(vp-cpy-ir :r6 0 :r0)
	(errorcase
		(call 'obj :inst_of `(:r0 (@ ,(f-path 'seq :vtable))) '(:r0 tmp))
		(gotoif `(,tmp = 0) 'error3))
		(call 'seq :get_length '(:r0) '(_ len))
		(vpif `(,len < :r8))
			(vp-cpy-rr len :r8)
		(endif)
		(vp-add-cr +ptr_size :r6)
	(loop-end)

	(call 'obj :ref '(:r11) {value})

	(vpif '(:r8 /= +max_int))
		(lisp-elem-index :r9 :r8)
		(lisp-elem-index :r10 :r8)

	(errorcase
		(gotoif '(:r9 < 0) 'error4)
		(gotoif '(:r10 < 0) 'error4)
		(gotoif '(:r9 > :r8) 'error4)
		(gotoif '(:r10 > :r8) 'error4))

		(vp-cpy-cr 1 :r8)
		(vpif '(:r9 > :r10))
			(vp-cpy-cr -1 :r8)
			(vp-sub-cr 1 :r9)
			(vp-sub-cr 1 :r10)
		(endif)
		(assign '(:r8 :r9 :r10 :r11 :r12 :r13) {dir, start, end, mode, func, args})

		(loop-while '(:r9 /= :r10) 'done)
			(call 'obj :deref {value})

			(call 'list :create :nil {params})
			(assign {args, start} '(:r0 :r9))
			(class/array/get_both :r0 :r10 :r11)
			(loop-start)
				(call 'seq :ref_element '((:r10 0) :r9) '(_ :r1))
				(assign {params} '(:r0))
				(call 'list :push_back '(:r0 :r1))
				(vp-add-cr +ptr_size :r10)
			(loop-until '(:r10 = :r11))

			(call 'num :create '(:r9) '(:r2))
			(assign {this} '(:r1))
			(assign '(:r2) {value})
			(call 'hmap :insert '((:r1 lisp_environment) (:r1 lisp_sym_underscore) :r2))
			(call 'obj :deref {value})

			(call 'lisp :repl_apply {this, params, func} {_, value})
			(call 'list :deref {params})
			(assign {value} '(:r1))

		(errorcase
			(f-bind 'error :vtable :r4)
			(assign '((:r1 obj_vtable)) '(:r3))
			(breakif '(:r3 = :r4) 'done))

			(assign {this, mode} '(:r0 :r2))
			(assign '((:r0 lisp_sym_nil)) '(:r0))
			(vpif '(:r2 /= :r0))
				(breakif '(:r1 = :r0) 'done)
			(else)
				(breakif '(:r1 /= :r0) 'done)
			(endif)

			(assign {dir, start, end} '(:r8 :r9 :r10))
			(vp-add-rr :r8 :r9)
			(assign '(:r9) {start})
		(loop-end)
	(endif)

(vp-label 'funcexit)
	(call 'lisp :env_pop {this} '(:r0 _))
	(assign {value} '(:r1))
	(exit 'seq :lisp_some '(:r0 :r1))
	(return)

(errorcase
(vp-label 'error1)
	(jump 'lisp :repl_error '(:r0 "(some! start end mode lambda seqs)" +error_msg_wrong_num_of_args :r1))
(vp-label 'error3)
	(call 'lisp :repl_error {this, "(some! start end mode lambda seqs)", +error_msg_not_a_sequence, args} {_, value})
	(goto 'funcexit)
(vp-label 'error4)
	(call 'lisp :repl_error {this, "(some! start end mode lambda seqs)", +error_msg_not_valid_index, args} {_, value})
	(goto 'funcexit)
	(signature '(num num obj obj list)))

	(pop-scope-syms)

(def-func-end)

(def-method 'seq :lisp_map)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this args value out func params)
		(int dir start end))

	(push-scope)
	(entry 'seq :lisp_map '(:r0 :r1))

	(errorif-lisp-args-sig-range :r1 4 5 'error1)

	(assign '(:r0 :r1) {this, args})
	(call 'lisp :env_push '(:r0))

	(assign {args} '(:r0))
	(assign '((:r0 array_length)) '(:r2))
	(vpif '(:r2 = 4))
		(list-bind-args :r0 '(:r9 :r10 :r11 :r12) '(:num :num :obj :list))
		(call 'list :create :nil '(:r0))
	(else)
		(list-bind-args :r0 '(:r9 :r10 :r11 :r12 :r0) '(:num :num :obj :list :list))
		(class/obj/ref :r0 :r1)
	(endif)
	(assign '(:r0) {out})

	(vp-cpy-cr +max_int :r8)
	(class/array/get_both :r12 :r6 :r7)
	(loop-while '(:r6 /= :r7))
		(vp-cpy-ir :r6 0 :r0)
	(errorcase
		(call 'obj :inst_of `(:r0 (@ ,(f-path 'seq :vtable))) '(:r0 :r1))
		(gotoif '(:r1 = 0) 'error3))
		(call 'seq :get_length '(:r0) '(_ :r1))
		(vpif '(:r1 < :r8))
			(vp-cpy-rr :r1 :r8)
		(endif)
		(vp-add-cr +ptr_size :r6)
	(loop-end)

	(vpif '(:r8 /= +max_int))
		(lisp-elem-index :r9 :r8)
		(lisp-elem-index :r10 :r8)

	(errorcase
		(gotoif '(:r9 < 0) 'error4)
		(gotoif '(:r10 < 0) 'error4)
		(gotoif '(:r9 > :r8) 'error4)
		(gotoif '(:r10 > :r8) 'error4))

		(vp-cpy-cr 1 :r8)
		(vpif '(:r9 > :r10))
			(vp-cpy-cr -1 :r8)
			(vp-sub-cr 1 :r9)
			(vp-sub-cr 1 :r10)
		(endif)
		(assign '(:r8 :r9 :r10 :r11 :r12) {dir, start, end, func, args})
		(assign {out} '(:r0))
		(assign '((:r0 array_length)) '(:r1))
		(vp-cpy-rr :r10 :r2)
		(vp-sub-rr :r9 :r2)
		(vp-mul-rr :r8 :r2)
		(vp-add-rr :r2 :r1)
		(call 'list :set_capacity '(:r0 :r1))

		(loop-while '(:r9 /= :r10))
			(call 'list :create :nil {params})
			(assign {args, start} '(:r0 :r9))
			(class/array/get_both :r0 :r10 :r11)
			(loop-start)
				(call 'seq :ref_element '((:r10 0) :r9) '(_ :r1))
				(assign {params} '(:r0))
				(call 'list :push_back '(:r0 :r1))
				(vp-add-cr +ptr_size :r10)
			(loop-until '(:r10 = :r11))

			(call 'num :create '(:r9) '(:r2))
			(assign {this} '(:r1))
			(assign '(:r2) {value})
			(call 'hmap :insert '((:r1 lisp_environment) (:r1 lisp_sym_underscore) :r2))
			(call 'obj :deref {value})

			(call 'lisp :repl_apply {this, params, func} {_, value})
			(call 'list :deref {params})

		(errorcase
			(assign {value} '(:r1))
			(f-bind 'error :vtable :r4)
			(assign '((:r1 obj_vtable)) '(:r3))
			(gotoif '(:r3 = :r4) 'error2))

			(call 'list :push_back {out, value})
			(assign {dir, start, end} '(:r8 :r9 :r10))
			(vp-add-rr :r8 :r9)
			(assign '(:r9) {start})
		(loop-end)
	(endif)

(vp-label 'funcexit)
	(call 'lisp :env_pop {this} '(:r0 _))
	(assign {out} '(:r1))
	(exit 'seq :lisp_map '(:r0 :r1))
	(return)

(errorcase
(vp-label 'error1)
	(jump 'lisp :repl_error '(:r0 "(map! start end lambda seqs [out])" +error_msg_wrong_types :r1))
(vp-label 'error2)
	(call 'obj :deref {out})
	(assign {value} {out})
	(goto 'funcexit)
(vp-label 'error3)
	(call 'obj :deref {out})
	(call 'lisp :repl_error {this, "(map! start end lambda seqs [out])", +error_msg_not_a_sequence, args} {_, out})
	(goto 'funcexit)
(vp-label 'error4)
	(call 'obj :deref {out})
	(call 'lisp :repl_error {this, "(map! start end lambda seqs [out])", +error_msg_not_valid_index, args} {_, out})
	(goto 'funcexit)
	(signature '(num num obj list list)))

	(pop-scope-syms)

(def-func-end)

(def-method 'seq :lisp_reduce)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this args value func params)
		(int dir start end))

	(push-scope)
	(entry 'seq :lisp_reduce '(:r0 :r1))

	(errorif-lisp-args-sig :r1 5 'error1)

	(assign '(:r0 :r1) {this, args})
	(call 'lisp :env_push '(:r0))

	(assign {args} '(:r0))
	(list-bind-args :r0 '(:r9 :r10 :r11 :r12 :r13) '(:num :num :obj :list :obj))

	(vp-cpy-cr +max_int :r8)
	(class/array/get_both :r12 :r6 :r7)
	(loop-while '(:r6 /= :r7))
		(vp-cpy-ir :r6 0 :r0)
	(errorcase
		(call 'obj :inst_of `(:r0 (@ ,(f-path 'seq :vtable))) '(:r0 :r1))
		(gotoif '(:r1 = 0) 'error3))
		(call 'seq :get_length '(:r0) '(_ :r1))
		(vpif '(:r1 < :r8))
			(vp-cpy-rr :r1 :r8)
		(endif)
		(vp-add-cr +ptr_size :r6)
	(loop-end)

	(assign '(:r13) {value})
	(class/obj/ref :r13 :r0)

	(vpif '(:r8 /= +max_int))
		(lisp-elem-index :r9 :r8)
		(lisp-elem-index :r10 :r8)

	(errorcase
		(gotoif '(:r9 < 0) 'error4)
		(gotoif '(:r10 < 0) 'error4)
		(gotoif '(:r9 > :r8) 'error4)
		(gotoif '(:r10 > :r8) 'error4))

		(vp-cpy-cr 1 :r8)
		(vpif '(:r9 > :r10))
			(vp-cpy-cr -1 :r8)
			(vp-sub-cr 1 :r9)
			(vp-sub-cr 1 :r10)
		(endif)
		(assign '(:r8 :r9 :r10 :r11 :r12) {dir, start, end, func, args})

		(loop-while '(:r9 /= :r10))
			(call 'list :create :nil {params})
			(call 'list :push_back {params, value})
			(assign {args, start} '(:r0 :r9))
			(class/array/get_both :r0 :r10 :r11)
			(loop-start)
				(call 'seq :ref_element '((:r10 0) :r9) '(_ :r1))
				(assign {params} '(:r0))
				(call 'list :push_back '(:r0 :r1))
				(vp-add-cr +ptr_size :r10)
			(loop-until '(:r10 = :r11))

			(call 'num :create '(:r9) '(:r2))
			(assign {this} '(:r1))
			(assign '(:r2) {value})
			(call 'hmap :insert '((:r1 lisp_environment) (:r1 lisp_sym_underscore) :r2))
			(call 'obj :deref {value})

			(call 'lisp :repl_apply {this, params, func} {_, value})
			(call 'list :deref {params})

		(errorcase
			(assign {value} '(:r1))
			(f-bind 'error :vtable :r4)
			(assign '((:r1 obj_vtable)) '(:r3))
			(gotoif '(:r3 = :r4) 'funcexit))

			(assign {dir, start, end} '(:r8 :r9 :r10))
			(vp-add-rr :r8 :r9)
			(assign '(:r9) {start})
		(loop-end)
	(endif)

(vp-label 'funcexit)
	(call 'lisp :env_pop {this} '(:r0 _))
	(assign {value} '(:r1))
	(exit 'seq :lisp_reduce '(:r0 :r1))
	(return)

(errorcase
(vp-label 'error1)
	(jump 'lisp :repl_error '(:r0 "(reduce! start end lambda seqs init)" +error_msg_wrong_types :r1))
(vp-label 'error3)
	(call 'lisp :repl_error {this, "(reduce! start end lambda seqs init)", +error_msg_not_a_sequence, args} {_, value})
	(goto 'funcexit)
(vp-label 'error4)
	(call 'lisp :repl_error {this, "(reduce! start end lambda seqs init)", +error_msg_not_valid_index, args} {_, value})
	(goto 'funcexit)
	(signature '(num num obj list obj)))

	(pop-scope-syms)

(def-func-end)
