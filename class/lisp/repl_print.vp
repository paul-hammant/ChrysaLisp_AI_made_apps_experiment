(include "lib/asm/func.inc")
(include "././stream/class.inc")
(include "././sym/class.inc")
(include "././func/class.inc")
(include "./class.inc")
(include "lib/consts/chars.inc")

(def-method 'lisp :repl_print)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = stream object (ptr)
	;:r2 = value
	;outputs
	;:r0 = lisp object (ptr)
	;trashes
	;:r1-:r14

	(def-struct local 0
		(ptr this stream value)
		(pptr iter_begin iter_end))

	(vp-alloc local_size)
	(entry 'lisp :repl_print '(:r0 :r1 :r2))

	(assign '(:r0 :r1 :r2 (:r2 obj_vtable)) '((:rsp local_this) (:rsp local_stream) (:rsp local_value) :r0))
	(switch 'exit)
		;lists
		(f-bind 'list :vtable :r3)
		(nextcaseif '(:r0 /= :r3))
		(assign '((:r2 array_length)) '(:r3))
		(vpif '(:r3 /= 0) 'notquote)
			(array-bind-args :r2 '(:r3))
			(assign '((:rsp local_this)) '(:r0))
			(switch)
				(assign '((:r0 lisp_sym_quote)) '(:r2))
				(nextcaseif '(:r3 /= :r2))
				(call 'stream :write_char '(:r1 +char_quote))
			(else)
				(assign '((:r0 lisp_func_quote)) '(:r2))
				(nextcaseif '(:r3 /= :r2))
				(call 'stream :write_char '(:r1 +char_quote))
			(else)
				(assign '((:r0 lisp_sym_qquote)) '(:r2))
				(nextcaseif '(:r3 /= :r2))
				(call 'stream :write_char '(:r1 +char_tick))
			(else)
				(assign '((:r0 lisp_func_qquote)) '(:r2))
				(nextcaseif '(:r3 /= :r2))
				(call 'stream :write_char '(:r1 +char_tick))
			(else)
				(assign '((:r0 lisp_sym_unquote)) '(:r2))
				(nextcaseif '(:r3 /= :r2))
				(call 'stream :write_char '(:r1 +char_comma))
			(else)
				(assign '((:r0 lisp_sym_splicing)) '(:r2))
				(breakif '(:r3 /= :r2) 'notquote)
				(call 'stream :write_char '(:r1 +char_tilde))
			(endswitch)
			(assign '((:rsp local_value)) '(:r0))
			(assign '((:r0 array_length)) '(:r1))
			(breakif '(:r1 < 2) 'exit)
			(array-bind-args :r0 '(_ :r2))
			(call 'lisp :repl_print '((:rsp local_this) (:rsp local_stream) :r2))
			(break 'exit)
		(endif)
		(call 'stream :write_char '(:r1 +char_lrb))
		(call 'list :get_both '((:rsp local_value)) '(_ :r1 :r2))
		(vpif '(:r1 /= :r2))
			(assign '(:r1 :r2) '((:rsp local_iter_begin) (:rsp local_iter_end)))
			(loop-start)
				(call 'trunc_func '((:rsp local_this) (:r1 0)) '(:r0 :r1))
				(call 'lisp :repl_print '(:r0 (:rsp local_stream) :r1))
				(assign '((:rsp local_iter_begin) (:rsp local_iter_end)) '(:r1 :r2))
				(vp-add-cr +long_size :r1)
				(breakif '(:r1 = :r2))
				(assign '(:r1) '((:rsp local_iter_begin)))
				(call 'stream :write_char '((:rsp local_stream) +char_space))
				(assign '((:rsp local_iter_begin)) '(:r1))
			(loop-end)
		(endif)
		(call 'stream :write_char '((:rsp local_stream) +char_rrb))
		(break)
	(default)
		;default to whatever the object does
		(call 'obj :print '(:r2 :r1))
	(endswitch)

	(exit 'lisp :repl_print '((:rsp local_this)))
	(vp-free local_size)
	(vp-ret)

(vp-label 'trunc_func)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = object (ptr)
	;trashes
	;:r1-:r4
	(vp-def (this obj iter_begin iter_end func))
	(assign `((,obj obj_vtable) (@ ,(f-path 'list :vtable)))
		`(,iter_begin ,iter_end))
	(vpif `(,iter_begin = ,iter_end))
		(class/array/get_both obj iter_begin iter_end)
		(vpif `(,iter_begin /= ,iter_end))
			(array-get-args iter_begin `(,iter_end))
			(assign `((,this lisp_func_lambda)) `(,func))
			(gotoif `(,iter_end = ,func) 'trunc)
			(assign `((,this lisp_func_macro)) `(,func))
			(gotoif `(,iter_end = ,func) 'trunc)
			(assign `((,this lisp_sym_lambda)) `(,func))
			(gotoif `(,iter_end = ,func) 'trunc)
			(assign `((,this lisp_sym_macro)) `(,func))
			(breakif `(,iter_end /= ,func))
		(vp-label 'trunc)
			(assign `((,this lisp_sym_trunc)) `(,obj))
		(endif)
	(endif)
	(vp-ret)

(def-func-end)
