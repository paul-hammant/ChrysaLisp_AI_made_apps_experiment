(include "././asm/func.inc")
(include "././consts/chars.inc")
(include "class/sym/class.inc")
(include "class/sstream/class.inc")
(include "class/list/class.inc")
(include "class/lisp/class.inc")
(include "sys/str/class.inc")

(def-func 'lib/xml/parse)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(int c)
		(ptr state)
	(offset res_start)
		(ptr states tokens) ;must be first 2 resources !
	(offset syms_start)
		(ptr sym_text sym_open sym_close sym_assign sym_string sym_symbol)
	(offset syms_end)
		(ptr not_symbol_chars open_chars close_chars sstoken)
	(offset res_end)
		(ptr stream resources this args))

	(defun write-token ()
		(call 'sstream :write_char {sstoken, c}))

	(defun output-c ()
		(call 'str :create_from_buffer {&c, 1} '(token))
		(bind '(l t) (method-input 'list :push_back))
		(assign `(,token) `(,t))
		(assign {tokens} `(,l))
		(call 'list :push_back `(,l ,t)))

	(defun output-token ()
		(call 'sstream :claim_string {sstoken} '(_ token))
		(bind '(l t) (method-input 'list :push_back))
		(assign `(,token) `(,t))
		(assign {tokens} `(,l))
		(call 'list :push_back `(,l ,t)))

	(defun output-state (&optional s)
		(if s
			(call 'list :push_back (cat {states,} s) '(_ obj tmp _))
			(call 'list :push_back {states, state} '(_ obj tmp _)))
		(class/obj/ref obj tmp))

	(defun find_char_in (s)
		(bind '(st ch _) (method-input 'str :find))
		(assign `(,c) `(,ch))
		(assign s `(,st))
		(d-call 'str :find `(,st ,ch 0) '(_ _ idx)))

	(entry '(:r0 :r1))

	(errorif-lisp-args-sig 'error :r1 1)

	(push-scope)
	(assign '(:r0 :r1) {this, args})

	(list-bind-args :r1 '(:r0) '(:stream))
	(assign '(:r0) {stream})

	(call 'str :create_from_buffer {0, str_gap} '(:r0))
	(call 'sstream :create '(:r0) {sstoken})
	(call 'list :create :nil {states})
	(call 'list :create :nil {tokens})
	(call 'str :create_from_buffer (list (cat (char +char_double_quote) {=<>}) 4) {not_symbol_chars})
	(call 'str :create_from_buffer {"</!-?", 5} {open_chars})
	(call 'str :create_from_buffer {">/-?", 4} {close_chars})

	;create state symbols
	(vp-def (table iter_begin iter_end) '(:r11 :r12 :r13))
	(assign {$states, &syms_start, &syms_end} `(,table ,iter_begin ,iter_end))
	(loop-start)
		(call 'sym :intern_cstr `(,table) `((,iter_begin 0)))
		(call 'sys_str :length `(,table) '(_ len))
		(vp-add-cr +ptr_size iter_begin)
		(vp-add-rr len table)
		(vp-add-cr 1 table)
	(loop-until `(,iter_begin = ,iter_end))

	;create resource tracker list
	(vp-def (res iter_begin iter_end) '(:r0 :r12 :r13))
	(call 'list :create :nil {resources})
	(assign {resources, &res_start, &res_end} `(,res ,iter_begin ,iter_end))
	(loop-start)
		(call 'list :push_back `(,res (,iter_begin 0)) '(res _ _ _))
		(vp-add-cr +ptr_size iter_begin)
	(loop-until `(,iter_begin = ,iter_end))

	(assign {sym_text} {state})
	(loop-start 'next_char)
		(call 'stream :read_char {stream} '(_ c))
		(breakif `(,c = -1))
		(assign `(,c) {c})
	(vp-label 'proc_char)
		(switch)
		(vp-def (state sym c) '(:r0 :r2 :r1))
		(assign {state, sym_text, c} `(,state ,sym ,c))
		(vpcase `(,state = ,sym))
			(switch)
			(continueif `(,c <= +char_space) 'next_char)
			(vpcase `(,c = +char_lt))
				(assign {sym_open} {state})
				(goto 'write_token_then_next)
			(default)
				(find_char_in {close_chars})
				(nextcaseif `(,idx = -1))
				(assign {sym_close} {state})
				(goto 'write_token_then_next)
			(vpcase `(,c = +char_equal))
				(output-c)
				(output-state {sym_assign})
				(continue 'next_char)
			(vpcase `(,c = +char_double_quote))
				(assign {sym_string} {state})
				(continue 'next_char)
			(default)
				(assign {sym_symbol} {state})
				(goto 'write_token_then_next)
			(endswitch)
		(default)
			(assign {sym_open} `(,sym))
			(nextcaseif `(,state /= ,sym))
			(find_char_in {open_chars})
			(gotoif `(,idx /= -1) 'write_token_then_next)
			(goto 'output_then_proc)
		(default)
			(assign {sym_close} `(,sym))
			(nextcaseif `(,state /= ,sym))
			(find_char_in {close_chars})
			(gotoif `(,idx /= -1) 'write_token_then_next)
			(goto 'output_then_proc)
		(default)
			(assign {sym_symbol} `(,sym))
			(nextcaseif `(,state /= ,sym))
			(gotoif `(,c <= +char_space) 'output_then_proc)
			(find_char_in {not_symbol_chars})
			(gotoif `(,idx = -1) 'write_token_then_next)
		(vp-label 'output_then_proc)
			(output-token)
			(output-state)
			(assign {sym_text} {state})
			(goto 'proc_char)
		(default)
			(gotoif `(,c /= +char_double_quote) 'write_token_then_next)
		(vp-label 'output_then_next)
			(output-token)
			(output-state)
			(assign {sym_text} {state})
			(continue 'next_char)
		(vp-label 'write_token_then_next)
			(write-token)
		(endswitch)
	(loop-end)

	(d-call 'list :slice {resources, 0, 2} {_, args})
	(call 'list :deref {resources})
	(exit {this, args})
	(pop-scope)
	(return)

(vp-label 'states)
	(vp-cstr ":text")
	(vp-cstr ":open")
	(vp-cstr ":close")
	(vp-cstr ":assign")
	(vp-cstr ":string")
	(vp-cstr ":symbol")

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(xml-parse stream)" +error_msg_wrong_types :r1))
	(signature '(stream)))

(def-func-end)
